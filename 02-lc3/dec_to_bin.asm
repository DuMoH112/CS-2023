; В R0 - Хранится указатель на массив (константа ARRAY)
; В R1 - Хранится исходное число (константа NUM)
; В R2 - Хранится ASCII символ 0 (константа ZERO)
; В R3 - Хранится целый результат при делении на 2

; В R4 - Временное хранилище локальных данных

.ORIG x3000 ; начальный адрес

    ; Загрузить константы в регистры
    LEA R0, ARRAY       ; Загружаем ARRAY в R0
    LD R1, NUM          ; Загружаем NUM в R1
    LD R2, ZERO         ; Загружаем ZERO в R2

    ADD R3, R3, #0      ; Обнуляем регистр R3

    ; Динамически сдвигаем указатель на последнию цифру числа
    ADD R4, R4, R1
    ADD R5, R5, #1
    ADD R6, R6, #-2     ; Степень двойки

    FIND_END_ARRAY
        ADD R4, R4, R6
        BRn INIT_POINT_ARRAY
        ADD R5, R5, #1
        ADD R6, R6, R6
        BR FIND_END_ARRAY


    INIT_POINT_ARRAY
        ADD R0, R0, R5      ; Сдвигаем указатель на последнию цифру числа
    ; ---

    ; Начало цикла
    LOOP
        ; Делить число в регистре R1 на 2 с остатком
        ADD R1, R1, #-2 ; R1 = R1 - 2
        BRn NEGATIVE    ; Если результат отрицателен, перейти к NEGATIVE
        ADD R3, R3, #1  ; Иначе увеличить результат деления на 1
        BR LOOP         ; Перейти к началу цикла

    ; Обработка отрицательного результата
    NEGATIVE            ; Восстановить последнюю цифру и преобразовать ее в символ
        ADD R4, R1, #2  ; R4 = R1 + 2 | На выходе будет 0 или 1
        ADD R4, R4, R2  ; R4 = R4 + ASCII код нуля
        STR R4, R0, #0  ; Сохраняем полученное число в массиве
        ADD R0, R0, #-1 ; Сдвигаем указатель массива   

        ADD R1, R3, #0  ; Скопировать результат деления в регистр R1
        BRz TO_END      ; Если он равен нулю, то завершаем программу
        AND R3, R3, #0  ; Иначе обнулить счетчик цифр
        BR LOOP         ; Перейти к началу цикла

    TO_END
        PUTS            ; Выводим массив с указателя в R0
        HALT

    NUM .FILL #137      ; Исходное число (10001001)
    ZERO .FILL x0030    ; Символ '0' в ASCII-коде
    ARRAY .BLKW #9      ; Указатель на массив

.END
